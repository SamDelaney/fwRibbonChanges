#!/bin/bash
# Initializes and clones git repos needed for FW development

GERRIT="gerrit.lsdev.sil.org"
GERRITPORT=59418

# In Calgary use repos on git directly, otherwise use repos on github
# REVIEW: it might be better to redirect in the config file (see git-fetch(1)), especially if
# we use submodules or other files that hardcode the URI.
#if [ "$(dnsdomainname 2>/dev/null)" == "wycliffe.ca" ]; then
	REPOURI="git://gerrit.lsdev.sil.org"
#else
#	REPOURI="git://github.com/sillsdev"
#fi

# Version of the alias section in the config file. Increment the number each time you make some
# changes to setting the alias/guitool section below so that the config gets updated when this
# script is run.
THISALIASVERSION=1

function readdefault {
	# parameters:
	# $1: prompt
	# $2: default value
	read -p "$1 ($2): " tmp
	echo "${tmp:-$2}"
}

fullname()
{
	local n f1 f2 f3 f4 f5 f6 f7
	n=$(whoami)
	if [ -r /etc/passwd ]; then
		while IFS=: read -r f1 f2 f3 f4 f5 f6 f7
		do
			[ "$f1" == "$n" ] && echo "${f5%%,*}"
		done </etc/passwd
	else
		echo "$n"
	fi
}

# Get the directory of the fwmeta repo
getfwmetadir()
{
	local dir olddir curdir
	curdir=$(pwd)
	dir=$curdir

	while true; do
		cd $dir
		dir=$(git rev-parse --show-toplevel 2> /dev/null)
		if [ -z $dir ]; then
			echo "$curdir"
			return
		fi
		cd $dir
		if test -d fwmeta && git config --file .git/config --get fwinit.initialized >/dev/null; then
			echo "$dir"
			return
		else
			olddir="$dir"
			dir=$(dirname "$dir")
			if [ "$olddir" == "$dir" ]; then
				echo "$curdir"
				return
			fi
		fi
	done
}

initrepo()
{
	repo=$1
	loc=${locations[$repo]}

	cwd=$(pwd)
	mkdir -p "$loc"
	cd "$loc"
	git init .

	if [ "$reset" == "1" ]; then
		git config --unset fwinit.initialized
		git config --unset fwinit.aliasversion
	fi

	# Initialize origin
	if ! git remote | grep -q origin; then
		addorigin=1
		git remote add origin "$REPOURI/$repo.git"
	fi

	# setup push URL
	if ! git config --get-all remote.origin.pushurl | grep -q "ssh://$gerritusername@$GERRIT:$GERRITPORT/$repo.git"; then
		git remote set-url --add --push origin "ssh://$gerritusername@$GERRIT:$GERRITPORT/$repo.git"
	fi

	# Remove all fetch statements for origin so that we can add them again
	git config --unset-all remote.origin.fetch

	# update settings for notes
	git config notes.rewrite.amend true
	git config notes.rewrite.rebase true
	git config notes.rewriteRef "refs/notes/*"
	git config notes.displayRef "refs/notes/*"
	if ! git config --get-all remote.origin.fetch | grep -q notes; then
		git config --add remote.origin.fetch "+refs/notes/*:refs/notes/*"
	fi

	# fetch branches and setup tracking branch
	git remote set-branches --add origin $branchlist
	git fetch origin

	if [ -n "$addorigin" ]; then
		# we need those two branches so that we can successfully initialize git-flow
		git checkout master
		git checkout develop
	fi

	# install hook
	if [ ! -f .git/hooks/commit-msg ]; then
		echo "Getting commit hook:"
		if [ -z "$2" ]; then
			scp -p -P $GERRITPORT "$gerritusername@$GERRIT:hooks/commit-msg" .git/hooks
		else
			cp "$2/.git/hooks/commit-msg" .git/hooks/
		fi
	fi

	# Initialize git flow
	if ! git config --get gitflow.branch.master &>/dev/null; then
		git flow init -d
	fi

	if [ "$(git config --get fwinit.aliasversion)" != "$THISALIASVERSION" ]; then
		# adding some alias
		echo "Adding alias:"
		if ! git config --get fwinit.initialized &>/dev/null; then
			if [ "$(uname)" == "Linux" ]; then
				# there's some conflict here. When we use git from the command line
				# we don't want gedit here, but when we use git-gui we can't use vi.
				# So we set it to gedit for now; user might have to adjust later.
				git config core.editor "gedit -w"
				git config gui.editor "gedit -w"
			else
				git config core.editor "$(dirname $0)/winedit.sh"
			fi
			git config merge.tool "$mergetool"
			git config diff.guitool "$mergetool"
			git config fwinit.initialized 1
		fi
		sedReplace="$(dirname "$0")"
		sedReplace=${sedReplace//\//\\\/} # replace all / with \/
		git config alias.featfin '!sh -c "SEDREPLACE/featfin.sh \$1" -'
		git config alias.review '!sh -c "SEDREPLACE/review.sh \$1 \$2" -'
		git config alias.release '!sh -c "SEDREPLACE/relfin.sh \$1" -'
		git config alias.hotfin '!sh -c "SEDREPLACE/hotfin.sh \$1" -'
		git config alias.supfin '!sh -c "SEDREPLACE/supfin.sh \$1" -'
		git config alias.mergepush '!sh -c "git mergetool -y && git commit && git push origin --all && git push origin --tags" -'
		# do this last so that we can replace multiple entries at once
		sed "s/SEDREPLACE/$sedReplace/g" .git/config 2>&1 > .git/config2
		mv .git/config2 .git/config

		git config guitool.Feature/Start.cmd 'git flow feature start $ARGS'
		git config guitool.Feature/Start.argprompt "Feature name (JIRA number)"
		git config "guitool.Feature/Submit for Code Review.cmd" 'git push origin HEAD:refs/for/develop/$CUR_BRANCH'
		git config guitool.Feature/Finish.cmd 'git featfin ${CUR_BRANCH#*/}'
		git config guitool.Feature/Publish.cmd 'git flow feature publish ${CUR_BRANCH#*/}'
		git config guitool.Feature/Track.cmd 'git flow feature track $ARGS'
		git config guitool.Feature/Track.argprompt "Name of the feature"

		git config guitool.Release/Start.cmd 'git flow release start $ARGS'
		git config guitool.Release/Start.argprompt "Name of the release"
		git config "guitool.Release/Submit for Code Review.cmd" 'git push origin HEAD:refs/for/$CUR_BRANCH'
		git config guitool.Release/Finish.cmd 'git release ${CUR_BRANCH#*/}'
		git config guitool.Release/Publish.cmd 'git flow release publish ${CUR_BRANCH#*/}'
		git config guitool.Release/Track.cmd 'git flow release track $ARGS'
		git config guitool.Release/Track.argprompt "Name of the release"

		git config guitool.Hotfix/Start.cmd 'git flow hotfix start $ARGS'
		git config guitool.Hotfix/Start.argprompt "Name of the fixed version"
		git config "guitool.Hotfix/Submit for Code Review.cmd" 'git push origin HEAD:refs/for/master/$CUR_BRANCH'
		git config guitool.Hotfix/Finish.cmd 'git hotfin ${CUR_BRANCH#*/}'

		git config guitool.Support/Start.cmd 'git flow support start $ARGS'
		git config guitool.Support/Start.argprompt "Name of the support branch and tag it is based on (e.g. '1.0 1.0')"
		git config "guitool.Support/Submit for Code Review.cmd" 'git push origin HEAD:refs/for/$CUR_BRANCH'
		git config guitool.Support/Finish.cmd 'git supfin $ARGS'
		git config guitool.Support/Finish.argprompt "Name of the new version"

		git config "guitool.Bypass Code Review.cmd" 'git push origin $CUR_BRANCH'
		git config "guitool.Interactive Rebase.cmd" 'git rebase -i $REVISION'
		git config "guitool.Interactive Rebase.revprompt" yes
		git config "guitool. Visual Diff.cmd" 'git difftool -y $FILENAME'
		git config "guitool. Visual Diff.needsfile" yes
		git config "guitool. Visual Diff.noconsole" yes
		git config "guitool.Visual Merge.cmd" 'git mergetool -y'
		git config "guitool.Visual Merge.noconsole" yes
		git config "guitool.Visual Merge and Push.cmd" 'git mergepush'
		git config "guitool.Visual Merge.noconsole" yes
		git config fwinit.aliasversion "$THISALIASVERSION"
	fi
	cd "$cwd"
}

basedir=$(getfwmetadir)
cd "$basedir"
if [ "$1" != "--recursive" ]; then
	if [ -d ".git" ]; then
		# fwmeta repo exists. Just update it
		git pull --rebase origin
	else
		# fwmeta repo doesn't exist yet. Clone it.
		git clone git://gerrit.lsdev.sil.org/fwmeta.git
		basedir=$basedir/fwmeta
	fi
	# recursive call so that we run with the latest version
	$basedir/fwmeta/initrepo --recursive $*
	exit
fi
shift
reset=0
[ "$1" == "--reset" ] && reset=1

# Sanity checks
if ! git flow version &>/dev/null; then
	echo "Can't find git-flow. Please install."
	exit 1
fi

gerritusername=$(git config --get fwinit.gerrituser)
username=$(git config --get user.name)
useremail=$(git config --get user.email)
mergetool=$(git config --get merge.tool)
mergetool=${mergetool:-p4merge}

savevalues=false

# Query user for variables
if [ -z "$username" ]; then
	username="${username:-$(fullname)}"
	username=$(readdefault "Full name" "$username")
	savevalues=true
fi
defname="${username// /_}"
defname="${defname,,}"
if [ -z "$useremail" ]; then
	useremail="${useremail:-$defname@sil.org}"
	useremail=$(readdefault "Email address" "$useremail")
	savevalues=true
fi
if [ -z "$gerritusername" ]; then
	gerritusername="${gerritusername:-$defname}"
	gerritusername=$(readdefault "Gerrit username" "${gerritusername}")
	savevalues=true
fi

if "$savevalues"; then
	# Store variables for later use
	git config --global user.name "$username"
	git config --global user.email "$useremail"
	git config --global fwinit.gerrituser "$gerritusername"
fi

if [ -z "$mergetool" ]; then
	mergetool=$(readdefault "Merge tool [p4merge, kdiff3]" "$mergetool")
fi

repolist=$(git config --get fwinit.repolist)
[ "$reset" == 1 ] && repolist=""
if [ -z "$repolist" ]; then
	echo "Available repos: FieldWorks FwDebian FwDocumentation FwHelps FwInstaller FwMovies FwSampleProjects FwSupportTools WorldPad"
	defaultlist="FieldWorks FwSampleProjects"
	repolist=$(readdefault "Repos to clone" "$defaultlist")
	git config fwinit.repolist "$repolist"
fi
#if [ "$(uname -s)" == "Linux" ]; then
#	linuxrepos=$(git config --get fwinit.linuxrepos)
#	[ "$reset" == 1 ] && linuxrepos=""
#	if [ -z "$linuxrepos" ]; then
#		echo "Additional repos for Linux: mono mono-basic gtk-sharp libgdiplus"
#		linuxrepos=$(readdefault "Additional Linux repos" "mono mono-basic gtk-sharp libgdiplus")
#		git config fwinit.linuxrepos "$linuxrepos"
#	fi
#fi
branchlist=$(git config --get fwinit.branchlist)
[ "$reset" == 1 ] && branchlist=""
if [ -z "$branchlist" ]; then
	branchlist=$(readdefault "Branches to fetch" "master develop")
	git config fwinit.branchlist "$branchlist"
fi

# the locations of the git repos
declare -A locations=(
	[fwmeta]=.
	[FieldWorks]=fw
	[FwMovies]="fw/DistFiles/Language Explorer/Movies"
	[FwSampleProjects]="fw/DistFiles/ReleaseData"
	[FwDocumentation]="fw/Doc"
	[FwHelps]="fw/DistFiles/Helps"
	[FwDebian]="fw/debian"
	[FwInstaller]="fw/Installer"
	[FwSupportTools]="fw/SupportTools"
	[WorldPad]="WorldPad"
	[mono]=mono/mono
	[mono-basic]=mono/mono-basic
	[gtk-sharp]=mono/gtk-sharp
	[libgdiplus]=mono/libgdiplus
	[test]=test
)

initrepo fwmeta

for repo in $repolist; do
	initrepo "$repo" "$basedir"
done
